using Interpolations

struct OperatingConditions
    Ω::Real    # Rotation speed [rad/s]
    θ75::Real  # Collective pitch [rad]
    v∞::Real   # Wind speed [m/s]
    ρ::Real    # Density of the air [kg/m³]
    μ::Real    # Dynamic viscosity of the air [Pa*s]
end

struct LocalGeometry
    diameter::Real  # Diameter of the propeller [m]
    r_loc::Real     # Radial location of [m]
    dr::Real        # Streamtube width [m]
    chord::Real     # Chord [m]
    geopitch::Real  # Geometric pitch [m]
end

struct BemSolution
    thrust::Real
    torque::Real
    radii::Vector{Real}
    thrust_dist::Vector{Real}
    torque_dist::Vector{Real}
    vu2p_dist::Vector{Real}
    va2_dist::Vector{Real}
    w2_dist::Vector{Real}
end

"""
    bem(prop, oper; sdiv=20)
Calculate the thrust and the torque generated by a propeller.

This function applies the blade element method to the propeller `prop`,
for the specified operating conditions `oper` and subdivisions `sdiv` in the blades.
"""
function bem(prop::Propeller, oper::OperatingConditions; sdiv=20)

    # Subdivise the propeller span.
    r_min = prop.geometry.stations[1]
    r_max = prop.geometry.diameter/2
    radii = range(r_min, r_max, sdiv)
    dr    = radii[2] - radii[1]  # TODO: not robust: fails for non-linear range

    # Get geometry parameters for the desired radii
    chords  = linear_interpolation(prop.geometry.stations, prop.geometry.chords,     extrapolation_bc=Line())(radii)
    pitches = linear_interpolation(prop.geometry.stations, prop.geometry.geopitches, extrapolation_bc=Line())(radii)

    # Preallocate the forces and speeds distributions.
    thrust_dist = zeros(length(radii))
    torque_dist = zeros(length(radii))
    vu2p_dist   = zeros(length(radii))
    va2_dist    = zeros(length(radii))
    w2_dist     = zeros(length(radii))


    # Compute the thrust and torque for all of these locations.
    # TODO: Maybe a bit cumbersome to use enumerate zip here
    for (i, (r, c, p)) ∈ enumerate(zip(radii, chords, pitches))

        geom = LocalGeometry(prop.geometry.diameter, r, dr, c, p)

        local_bem_sol = local_bem(geom, prop.airfoil, oper)
        thrust_dist[i] = local_bem_sol[1]
        torque_dist[i] = local_bem_sol[2]
        vu2p_dist[i]   = local_bem_sol[3]
        va2_dist[i]    = local_bem_sol[4]
        w2_dist[i]     = local_bem_sol[5]
    end

    # Total thrust and torque exerted by the propeller.
    # NOTE: this assumes that the blades do not influence each other.
    # This is a safe assumption, as long as the nuber of blades
    # is not too high.
    thrust = sum(thrust_dist) * prop.geometry.n_blades
    torque = sum(torque_dist) * prop.geometry.n_blades

    # Return relevant quantities
    BemSolution(thrust, torque, radii, thrust_dist, torque_dist, vu2p_dist, va2_dist, w2_dist)
end

"""
    local_bem(geom, airfoil, oper; kwargs)
Detemine the momentum balance in one stream tube, for one blade.
"""
function local_bem(geom::LocalGeometry, airfoil::AirfoilPolar, oper::OperatingConditions;
                   rtol=1e-3, atol=1e-2, maxiter=50)

    # Set the upstream values
    v1 = oper.v∞
    vu2m = 0

    # Initial guesstimates
    va3 = v1
    vu2p = vu2m

    # Initial ...
    n_iter = 0
    thrust = torque = vu2p = va2 = w2 = 0

    # Determine forces and velocities iteratively.
    while true

        n_iter += 1

        # Velocity components at the propeller disk
        va2 = wa2 = (v1 + va3) / 2
        vu2 = vu2p / 2
        wu2 = vu2 - oper.Ω*geom.r_loc

        mass_flow = 2π * geom.r_loc * geom.dr * va2

        # New estimates for w2 and β2
        w2 = √(wa2^2 + wu2^2)
        β2 = atan(wu2/wa2)

        # TODO: this is messy
        stagger(r::Real) = atan(geom.geopitch/(2π*r))
        pitch = stagger(geom.r_loc) - stagger(0.75*geom.diameter) + oper.θ75
        aoa = pitch - (π/2 + β2)
        @show (pitch|>rad2deg) #(aoa|>rad2deg)
        Re  = oper.ρ * w2 * geom.chord / oper.μ

        # PERF: maybe keep lerp creation outside the loop
        lerp_cl = linear_interpolation((airfoil.aoa, airfoil.Re), airfoil.cl)
        lerp_cd = linear_interpolation((airfoil.aoa, airfoil.Re), airfoil.cd)
        cl = lerp_cl(aoa, Re)
        cd = lerp_cd(aoa, Re)

        lift = 1//2 * oper.ρ * w2^2 * geom.chord * geom.dr * cl
        drag = 1//2 * oper.ρ * w2^2 * geom.chord * geom.dr * cd

        thrust =  lift*sin(β2) + drag*cos(β2)
        torque = (lift*cos(β2) - drag*sin(β2)) * geom.r_loc

        # New approximations for the absolute velocity components
        va3_new  = v1 + thrust/mass_flow
        vu2p_new = torque / (mass_flow * geom.r_loc)

        # Stop the iterations if the speeds have sufficiently converged, or if the maximum
        # number of iterations has been reached.
        n_iter == maxiter && break
        isapprox(va3,  va3_new,  atol=atol, rtol=rtol) &&
        isapprox(vu2p, vu2p_new, atol=atol, rtol=rtol) && break

        # Otherwise update the speeds for the next iteration.
        vu2p = vu2p_new
        va3  = va3_new
    end

    # Return relevant quantities
    thrust, torque, vu2p, va2, w2

end

